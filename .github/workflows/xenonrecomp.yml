# XenonRecomp Workflow
# 
# This workflow automates the process of decompiling Xbox 360 executable (XEX) files
# using the XenonRecomp tool, which converts PowerPC assembly to C++ source code.
#
# Purpose:
# - Decompile XEX files to generate human-readable C++ code
# - Detect and handle jump tables for better decompilation quality
# - Commit generated C++ files back to the repository
#
# Workflow Steps:
# 1. Set up build environment (Clang 18, CMake)
# 2. Clone and build XenonRecomp from source
# 3. Verify input XEX file exists
# 4. Run XenonAnalyse to detect jump tables (optional, may not find any)
# 5. Create configuration file with paths and optimization settings
# 6. Run XenonRecomp to generate C++ files
# 7. Commit and push generated files
#
# Troubleshooting:
# - If XenonRecomp crashes with segmentation fault (exit code 139):
#   * The XEX file may be incompatible or use unsupported features
#   * Check the workflow logs for detailed error messages and core dumps
#   * Partial output may still be generated and committed
# - If no files are generated:
#   * Verify the XEX file path is correct
#   * Check that the XEX file is a valid Xbox 360 executable
#   * Review XenonRecomp documentation for supported XEX formats
# - Configuration options can be adjusted in the "Create XenonRecomp configuration file" step
#
# Manual Triggering:
# - Navigate to Actions → XenonRecomp Workflow → Run workflow
# - Specify the XEX file path (default: dolphin/dolphin.xex)
# - Specify the output directory (default: generated_cpp)
name: XenonRecomp Workflow

on:
  workflow_dispatch:
    inputs:
      xex_file_path:
        description: 'Path to the dolphin.xex file (relative to repository root)'
        required: false
        default: 'dolphin/dolphin.xex'
      output_directory:
        description: 'Directory for generated .cpp files'
        required: false
        default: 'generated_cpp'

jobs:
  recompile:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
    
    steps:
      - name: Check out Test repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Set up Clang 18
        run: |
          # Add LLVM repository and install Clang 18 using modern gpg method
          wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo gpg --dearmor -o /etc/apt/trusted.gpg.d/llvm.gpg
          echo "deb https://apt.llvm.org/$(lsb_release -cs)/ llvm-toolchain-$(lsb_release -cs)-18 main" | sudo tee /etc/apt/sources.list.d/llvm.list
          sudo apt-get update
          sudo apt-get install -y clang-18 clang++-18
          sudo update-alternatives --install /usr/bin/clang clang /usr/bin/clang-18 100
          sudo update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-18 100
          clang --version
          clang++ --version
      
      - name: Install CMake
        run: |
          sudo apt-get install -y cmake
          cmake --version
      
      - name: Clone XenonRecomp repository
        run: |
          cd ${{ github.workspace }}
          git clone --recursive https://github.com/hedge-dev/XenonRecomp.git
          cd XenonRecomp
          git log -1 --oneline
      
      # Clone and build xex1tool for XEX decryption
      # xex1tool supports devkit, retail, and pre-release encryption keys
      # This is needed because dolphin.xex is encrypted with a devkit key,
      # which XenonRecomp doesn't support natively
      - name: Clone and build xex1tool
        run: |
          cd ${{ github.workspace }}
          echo "Cloning idaxex repository (contains xex1tool)..."
          git clone --recursive https://github.com/emoose/idaxex.git
          cd idaxex
          git log -1 --oneline
          
          echo "Building xex1tool..."
          cd xex1tool
          mkdir -p build
          cd build
          cmake ..
          make -j$(nproc)
          
          echo "xex1tool built successfully:"
          ls -la xex1tool
          ./xex1tool 2>&1 || true
      
      # Build the XenonRecomp tool from source
      # This compiles the XenonRecomp, XenonAnalyse, and XenonUtils components
      # Using RelWithDebInfo to get debug symbols for better crash diagnostics
      - name: Build XenonRecomp
        run: |
          cd ${{ github.workspace }}/XenonRecomp
          mkdir -p build
          cd build
          
          echo "Configuring CMake with Clang 18 (RelWithDebInfo for debug symbols)..."
          cmake .. -DCMAKE_BUILD_TYPE=RelWithDebInfo -DCMAKE_C_COMPILER=clang-18 -DCMAKE_CXX_COMPILER=clang++-18 -DCMAKE_CXX_FLAGS="-fno-omit-frame-pointer -g"
          
          echo "Building XenonRecomp..."
          cmake --build . --config RelWithDebInfo
          
          echo "Build completed"
          echo "Built binaries:"
          ls -la
      
      # Verify that the XEX file exists in the repository
      # The XEX file must be committed to the repository before running this workflow
      # Default path: dolphin/dolphin.xex
      - name: Verify XEX file exists
        run: |
          XEX_FILE="${{ github.workspace }}/${{ inputs.xex_file_path }}"
          echo "Checking for XEX file at: $XEX_FILE"
          
          if [ ! -f "$XEX_FILE" ]; then
            echo "ERROR: XEX file not found at $XEX_FILE"
            echo ""
            echo "Please ensure the XEX file is committed to the repository at:"
            echo "  ${{ inputs.xex_file_path }}"
            echo ""
            echo "Available files in repository:"
            find . -name "*.xex" -o -name "*.XEX" 2>/dev/null || echo "No XEX files found"
            exit 1
          fi
          
          echo "XEX file found: $XEX_FILE"
          echo "File size: $(stat -c%s "$XEX_FILE" 2>/dev/null || echo "unknown") bytes"
          ls -lh "$XEX_FILE"
      
      # Parse and validate XEX headers to help diagnose any issues
      # This step dumps the XEX header structure to help debug crashes
      - name: Validate XEX file headers
        run: |
          XEX_FILE="${{ github.workspace }}/${{ inputs.xex_file_path }}"
          echo "========================================="
          echo "XEX Header Analysis"
          echo "========================================="
          
          python3 << PYEOF
          import struct
          import hashlib

          with open('$XEX_FILE', 'rb') as f:
              data = f.read()

          print(f"File size: {len(data)} bytes")
          print(f"SHA256: {hashlib.sha256(data).hexdigest()}")
          print()

          # Check magic
          magic = data[0:4]
          if magic != b'XEX2':
              print(f"ERROR: Invalid magic bytes: {magic.hex()} (expected 58455832 for XEX2)")
              exit(1)

          # Parse XEX2 header
          module_flags = struct.unpack('>I', data[4:8])[0]
          header_size = struct.unpack('>I', data[8:12])[0]
          security_offset = struct.unpack('>I', data[16:20])[0]
          header_count = struct.unpack('>I', data[20:24])[0]

          print("=== XEX2 Header ===")
          print(f"Magic: XEX2")
          print(f"Module Flags: 0x{module_flags:08X}")
          print(f"Header Size: {header_size} (0x{header_size:X})")
          print(f"Security Offset: {security_offset} (0x{security_offset:X})")
          print(f"Header Count: {header_count}")

          # Parse optional headers
          print(f"\n=== Optional Headers ({header_count} total) ===")
          opt_header_offset = 24
          file_format_info_offset = None
          
          for i in range(header_count):
              key = struct.unpack('>I', data[opt_header_offset:opt_header_offset+4])[0]
              value = struct.unpack('>I', data[opt_header_offset+4:opt_header_offset+8])[0]
              
              key_names = {
                  0x000003FF: "FILE_FORMAT_INFO",
                  0x000005FF: "DELTA_PATCH_DESCRIPTOR",
                  0x00010100: "ENTRY_POINT",
                  0x00010201: "IMAGE_BASE_ADDRESS",
                  0x000103FF: "IMPORT_LIBRARIES",
              }
              
              key_name = key_names.get(key, f"0x{key:08X}")
              print(f"  [{i}] {key_name}: 0x{value:08X}")
              
              if key == 0x000003FF:
                  file_format_info_offset = value
              if key == 0x000005FF:
                  print("    *** WARNING: DELTA_PATCH_DESCRIPTOR found - this XEX may require a base file ***")
              
              opt_header_offset += 8

          # Parse FILE_FORMAT_INFO if found
          if file_format_info_offset:
              info_size = struct.unpack('>I', data[file_format_info_offset:file_format_info_offset+4])[0]
              encryption_type = struct.unpack('>H', data[file_format_info_offset+4:file_format_info_offset+6])[0]
              compression_type = struct.unpack('>H', data[file_format_info_offset+6:file_format_info_offset+8])[0]
              
              compression_names = {0: "NONE", 1: "BASIC", 2: "NORMAL", 3: "DELTA"}
              encryption_names = {0: "NONE", 1: "NORMAL"}
              
              print(f"\n=== FILE_FORMAT_INFO ===")
              print(f"  Info Size: {info_size}")
              print(f"  Encryption: {encryption_names.get(encryption_type, 'UNKNOWN')} ({encryption_type})")
              print(f"  Compression: {compression_names.get(compression_type, 'UNKNOWN')} ({compression_type})")
              
              if compression_type == 3:
                  print("\n  *** ERROR: DELTA compression is NOT supported by XenonRecomp! ***")
                  print("  This XEX requires a base XEX file to decompress.")
                  exit(1)
              
              if compression_type > 2:
                  print(f"\n  *** WARNING: Unknown compression type {compression_type} ***")

          # Parse security info
          print(f"\n=== Security Info ===")
          sec_header_size = struct.unpack('>I', data[security_offset:security_offset+4])[0]
          image_size = struct.unpack('>I', data[security_offset+4:security_offset+8])[0]
          print(f"  Security Header Size: {sec_header_size}")
          print(f"  Image Size: {image_size} (0x{image_size:X})")

          print("\n=== First 64 bytes (hex) ===")
          print(data[:64].hex())
          
          print("\nXEX header validation passed!")
          PYEOF
      
      # Decrypt the XEX file using xex1tool
      # This step extracts the decrypted basefile (PE) from the XEX
      # xex1tool supports devkit, retail, and pre-release encryption keys
      # The decrypted file will be used by XenonRecomp instead of the encrypted XEX
      - name: Decrypt XEX file using xex1tool
        id: decrypt_xex
        run: |
          XEX_FILE="${{ github.workspace }}/${{ inputs.xex_file_path }}"
          XEX1TOOL="${{ github.workspace }}/idaxex/xex1tool/build/xex1tool"
          DECRYPTED_DIR="${{ github.workspace }}/decrypted"
          DECRYPTED_FILE="$DECRYPTED_DIR/basefile.bin"
          
          echo "========================================="
          echo "XEX Decryption using xex1tool"
          echo "========================================="
          
          # Create output directory for decrypted file
          mkdir -p "$DECRYPTED_DIR"
          
          # First, list XEX info to see encryption type
          echo "Analyzing XEX file..."
          "$XEX1TOOL" -l "$XEX_FILE" 2>&1 || true
          echo ""
          
          # Extract the decrypted basefile
          echo "Extracting decrypted basefile..."
          "$XEX1TOOL" -b "$DECRYPTED_FILE" "$XEX_FILE"
          
          if [ -f "$DECRYPTED_FILE" ]; then
            echo "Decrypted basefile extracted successfully!"
            echo "File size: $(stat -c%s "$DECRYPTED_FILE") bytes"
            
            # Verify the decrypted file starts with MZ (PE header)
            MAGIC=$(xxd -l 2 -p "$DECRYPTED_FILE")
            if [ "$MAGIC" = "4d5a" ]; then
              echo "Verified: Decrypted file has valid PE header (MZ)"
            else
              echo "WARNING: Decrypted file does not start with MZ (got: $MAGIC)"
              echo "This may indicate decryption issues"
            fi
            
            # Output the path for use in later steps
            echo "decrypted_file=$DECRYPTED_FILE" >> $GITHUB_OUTPUT
            echo "decrypted_dir=$DECRYPTED_DIR" >> $GITHUB_OUTPUT
          else
            echo "ERROR: Failed to extract decrypted basefile"
            exit 1
          fi
      
      - name: Create output directory
        run: |
          OUTPUT_DIR="${{ github.workspace }}/${{ inputs.output_directory }}"
          mkdir -p "$OUTPUT_DIR"
          echo "Output directory created: $OUTPUT_DIR"
      
      # XenonAnalyse detects jump tables in the XEX file
      # Jump tables are used for optimizing switch statements in the decompiled code
      # This step may not find jump tables, which is acceptable for many XEX files
      - name: Run XenonAnalyse to detect jump tables
        id: xenonanalyse
        run: |
          cd ${{ github.workspace }}/XenonRecomp/build
          XEX_FILE="${{ github.workspace }}/${{ inputs.xex_file_path }}"
          JUMP_TABLES_OUTPUT="${{ github.workspace }}/jump_tables.toml"
          XENONANALYSE_BINARY="./XenonAnalyse/XenonAnalyse"
          
          echo "Running XenonAnalyse..."
          echo "XEX File: $XEX_FILE"
          echo "Output: $JUMP_TABLES_OUTPUT"
          echo "XenonAnalyse binary: $XENONANALYSE_BINARY"
          
          # Verify the binary exists
          if [ ! -f "$XENONANALYSE_BINARY" ]; then
            echo "WARNING: XenonAnalyse binary not found at $XENONANALYSE_BINARY"
            echo "Listing build directory contents:"
            ls -la
            ls -la XenonAnalyse/ 2>/dev/null || echo "XenonAnalyse directory not found"
            echo "has_jump_tables=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # XenonAnalyse may fail if no jump tables are detected, which is acceptable
          set +e
          "$XENONANALYSE_BINARY" "$XEX_FILE" "$JUMP_TABLES_OUTPUT"
          EXIT_CODE=$?
          set -e
          
          if [ $EXIT_CODE -eq 0 ]; then
            echo "XenonAnalyse completed successfully"
          else
            echo "XenonAnalyse exited with code $EXIT_CODE (this may be expected if no jump tables found)"
          fi
          
          # Check if jump tables file was generated and has content
          if [ -f "$JUMP_TABLES_OUTPUT" ] && [ -s "$JUMP_TABLES_OUTPUT" ]; then
            echo "Jump tables TOML generated:"
            head -n 20 "$JUMP_TABLES_OUTPUT"
            echo "has_jump_tables=true" >> $GITHUB_OUTPUT
          else
            echo "No jump tables detected or file is empty"
            rm -f "$JUMP_TABLES_OUTPUT"
            echo "has_jump_tables=false" >> $GITHUB_OUTPUT
          fi
      
      # Create configuration file for XenonRecomp
      # This file specifies input/output paths and optimization settings
      # IMPORTANT: XenonRecomp expects RELATIVE paths in the config file!
      # It concatenates config.directoryPath + config.filePath internally,
      # so using absolute paths would create invalid paths like:
      # /home/runner/work/Test/Test//home/runner/work/Test/Test/dolphin/dolphin.xex
      # 
      # NOTE: We now use the DECRYPTED basefile instead of the encrypted XEX!
      # The decrypted file was extracted by xex1tool in the previous step.
      # Only includes switch_table_file_path if jump tables were detected
      - name: Create XenonRecomp configuration file
        run: |
          # Use RELATIVE paths for XenonRecomp config (it will prepend directoryPath)
          # Point to the decrypted basefile instead of the encrypted XEX
          DECRYPTED_FILE_RELATIVE="decrypted/basefile.bin"
          OUTPUT_DIR_RELATIVE="${{ inputs.output_directory }}"
          JUMP_TABLES_FILE_RELATIVE="jump_tables.toml"
          CONFIG_FILE="${{ github.workspace }}/xenonrecomp_config.toml"
          HAS_JUMP_TABLES="${{ steps.xenonanalyse.outputs.has_jump_tables }}"
          
          # Absolute paths for verification only
          DECRYPTED_FILE_ABSOLUTE="${{ steps.decrypt_xex.outputs.decrypted_file }}"
          OUTPUT_DIR_ABSOLUTE="${{ github.workspace }}/${{ inputs.output_directory }}"
          JUMP_TABLES_FILE_ABSOLUTE="${{ github.workspace }}/jump_tables.toml"
          
          echo "Creating configuration file with RELATIVE paths..."
          echo "Using DECRYPTED basefile instead of encrypted XEX"
          echo "Has jump tables: $HAS_JUMP_TABLES"
          echo ""
          echo "Relative paths (for config):"
          echo "  file_path: $DECRYPTED_FILE_RELATIVE"
          echo "  out_directory_path: $OUTPUT_DIR_RELATIVE"
          echo "  switch_table_file_path: $JUMP_TABLES_FILE_RELATIVE"
          echo ""
          echo "Absolute paths (for verification):"
          echo "  Decrypted file: $DECRYPTED_FILE_ABSOLUTE"
          echo "  Output dir: $OUTPUT_DIR_ABSOLUTE"
          
          # Verify decrypted file exists
          if [ ! -f "$DECRYPTED_FILE_ABSOLUTE" ]; then
            echo "ERROR: Decrypted file not found at $DECRYPTED_FILE_ABSOLUTE"
            exit 1
          fi
          echo "Decrypted file exists: YES"
          
          # Create the [main] section with all config options
          # Note: XenonRecomp expects ALL config keys inside [main], not in separate tables
          {
            printf '[main]\n'
            printf 'file_path = "%s"\n' "$DECRYPTED_FILE_RELATIVE"
            printf 'out_directory_path = "%s"\n' "$OUTPUT_DIR_RELATIVE"
          } > "$CONFIG_FILE"
          
          # Only add switch_table_file_path if jump tables were detected
          if [ "$HAS_JUMP_TABLES" = "true" ] && [ -f "$JUMP_TABLES_FILE_ABSOLUTE" ]; then
            printf 'switch_table_file_path = "%s"\n' "$JUMP_TABLES_FILE_RELATIVE" >> "$CONFIG_FILE"
            echo "Including jump tables file in configuration"
          else
            echo "Skipping switch_table_file_path (no jump tables detected)"
          fi
          
          # Add optimization flags (all inside [main] section, not a separate table)
          # These are disabled by default for initial recompilation attempts
          {
            printf '\n# Optimization flags (keep disabled until recompilation works)\n'
            printf 'skip_lr = false\n'
            printf 'skip_msr = false\n'
            printf 'ctr_as_local = false\n'
            printf 'xer_as_local = false\n'
            printf 'reserved_as_local = false\n'
            printf 'cr_as_local = false\n'
            printf 'non_argument_as_local = false\n'
            printf 'non_volatile_as_local = false\n'
          } >> "$CONFIG_FILE"
          
          echo "Configuration file created:"
          cat "$CONFIG_FILE"
          echo ""
          echo "Verifying file paths in configuration..."
          echo "XEX file exists: $(test -f "$XEX_FILE" && echo "YES" || echo "NO")"
          echo "Output directory exists: $(test -d "$OUTPUT_DIR" && echo "YES" || echo "NO")"
          if [ "$HAS_JUMP_TABLES" = "true" ]; then
            echo "Jump tables file exists: $(test -f "$JUMP_TABLES_FILE" && echo "YES" || echo "NO")"
          fi
      
      # Execute XenonRecomp to decompile the XEX file
      # This step may fail with segmentation faults if the XEX file has compatibility issues
      # Enhanced with detailed logging and error handling for troubleshooting
      - name: Run XenonRecomp to generate C++ files
        run: |
          cd ${{ github.workspace }}
          CONFIG_FILE="${{ github.workspace }}/xenonrecomp_config.toml"
          PPC_CONTEXT_HEADER="${{ github.workspace }}/XenonRecomp/XenonUtils/ppc_context.h"
          OUTPUT_DIR="${{ github.workspace }}/${{ inputs.output_directory }}"
          XENONRECOMP_BINARY="${{ github.workspace }}/XenonRecomp/build/XenonRecomp/XenonRecomp"
          
          echo "========================================="
          echo "XenonRecomp Execution - Pre-flight Check"
          echo "========================================="
          echo "Working directory: $(pwd)"
          echo "Config file: $CONFIG_FILE"
          echo "PPC Context Header: $PPC_CONTEXT_HEADER"
          echo "Output directory: $OUTPUT_DIR"
          echo "XenonRecomp binary: $XENONRECOMP_BINARY"
          echo ""
          
          echo "Validating inputs..."
          if [ ! -f "$CONFIG_FILE" ]; then
            echo "ERROR: Config file not found at $CONFIG_FILE"
            exit 1
          fi
          echo "✓ Config file exists"
          
          if [ ! -f "$PPC_CONTEXT_HEADER" ]; then
            echo "ERROR: PPC context header not found at $PPC_CONTEXT_HEADER"
            exit 1
          fi
          echo "✓ PPC context header exists"
          
          if [ ! -f "$XENONRECOMP_BINARY" ]; then
            echo "ERROR: XenonRecomp binary not found at $XENONRECOMP_BINARY"
            exit 1
          fi
          echo "✓ XenonRecomp binary exists"
          
          if [ ! -x "$XENONRECOMP_BINARY" ]; then
            echo "WARNING: XenonRecomp binary is not executable, attempting to fix..."
            chmod +x "$XENONRECOMP_BINARY"
          fi
          echo "✓ XenonRecomp binary is executable"
          
          echo ""
          echo "Configuration file contents:"
          echo "----------------------------"
          cat "$CONFIG_FILE"
          echo "----------------------------"
          echo ""
          
          # Enable core dumps for debugging segmentation faults
          ulimit -c unlimited
          echo "Core dumps enabled (ulimit -c: $(ulimit -c))"
          echo ""
          
          echo "========================================="
          echo "Running XenonRecomp..."
          echo "========================================="
          
          # Run XenonRecomp with error handling
          set +e  # Don't exit on error
          "$XENONRECOMP_BINARY" "$CONFIG_FILE" "$PPC_CONTEXT_HEADER"
          EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          # If XenonRecomp crashed, try to get a detailed backtrace with gdb
          # The binary is built with RelWithDebInfo so we should get file:line info
          if [ $EXIT_CODE -eq 139 ]; then
            echo ""
            echo "========================================="
            echo "Segmentation fault detected! Getting detailed backtrace with gdb..."
            echo "========================================="
            sudo apt-get update -qq && sudo apt-get install -y -qq gdb
            set +e
            # Run with gdb to get detailed backtrace with file:line information
            gdb --batch \
              -ex "set print frame-arguments all" \
              -ex "set print pretty on" \
              -ex "run" \
              -ex "echo \n=== BACKTRACE ===\n" \
              -ex "bt full" \
              -ex "echo \n=== REGISTERS ===\n" \
              -ex "info registers" \
              -ex "echo \n=== CURRENT FRAME INFO ===\n" \
              -ex "info frame" \
              -ex "echo \n=== LOCAL VARIABLES ===\n" \
              -ex "info locals" \
              -ex "quit" \
              --args "$XENONRECOMP_BINARY" "$CONFIG_FILE" "$PPC_CONTEXT_HEADER" 2>&1 || echo "gdb failed to run"
            set -e
          fi
          
          echo ""
          echo "========================================="
          echo "XenonRecomp Exit Code: $EXIT_CODE"
          echo "========================================="
          
          if [ $EXIT_CODE -eq 0 ]; then
            echo "✓ XenonRecomp completed successfully"
          elif [ $EXIT_CODE -eq 139 ]; then
            echo "ERROR: XenonRecomp crashed with segmentation fault (exit code 139)"
            echo ""
            echo "Troubleshooting Information:"
            echo "- The XEX file may be incompatible or corrupted"
            echo "- The XenonRecomp binary may have issues with this specific XEX format"
            echo "- Check if there are core dump files for detailed debugging"
            echo ""
            
            # Check for core dumps
            if ls core.* core 2>/dev/null | grep -q .; then
              echo "Core dump files found:"
              ls -lh core.* core 2>/dev/null
              echo ""
              echo "To debug, download the core file and run:"
              echo "gdb $XENONRECOMP_BINARY core"
            else
              echo "No core dump files found"
            fi
            
            # Check if any output was generated before the crash
            if [ -d "$OUTPUT_DIR" ] && [ "$(ls -A $OUTPUT_DIR 2>/dev/null)" ]; then
              echo ""
              echo "Partial output was generated before crash:"
              ls -lah "$OUTPUT_DIR"
              echo ""
              echo "Continuing workflow with partial results..."
            else
              echo ""
              echo "No output was generated before crash"
              exit 1
            fi
          else
            echo "ERROR: XenonRecomp failed with exit code $EXIT_CODE"
            echo ""
            echo "The XEX file may require additional configuration or analysis"
            echo "Please check the XenonRecomp documentation for more details"
            echo ""
            
            # Check if partial output was generated
            if [ -d "$OUTPUT_DIR" ] && [ "$(ls -A $OUTPUT_DIR 2>/dev/null)" ]; then
              echo "Partial output was generated:"
              ls -lah "$OUTPUT_DIR"
              echo ""
              echo "Continuing workflow with partial results..."
            else
              echo "No output was generated"
              exit 1
            fi
          fi
          
          echo ""
          echo "Checking generated files:"
          if [ -d "$OUTPUT_DIR" ]; then
            FILE_COUNT=$(find "$OUTPUT_DIR" -type f | wc -l)
            echo "Total files generated: $FILE_COUNT"
            if [ $FILE_COUNT -gt 0 ]; then
              echo "Sample of generated files:"
              find "$OUTPUT_DIR" -type f | head -20
            fi
          else
            echo "Output directory does not exist"
          fi
      
      # Display a summary of generated C++ files
      # This helps verify the decompilation was successful
      - name: List generated C++ files
        if: always()  # Run even if previous step had issues
        run: |
          OUTPUT_DIR="${{ github.workspace }}/${{ inputs.output_directory }}"
          
          echo "========================================="
          echo "Generated Files Summary"
          echo "========================================="
          
          if [ ! -d "$OUTPUT_DIR" ]; then
            echo "ERROR: Output directory does not exist at $OUTPUT_DIR"
            exit 1
          fi
          
          FILE_COUNT=$(find "$OUTPUT_DIR" -type f 2>/dev/null | wc -l)
          echo "Output directory: $OUTPUT_DIR"
          echo "Total files generated: $FILE_COUNT"
          echo ""
          
          if [ $FILE_COUNT -eq 0 ]; then
            echo "WARNING: No files were generated"
            echo "This may indicate XenonRecomp failed or crashed before generating output"
            exit 1
          fi
          
          echo "Generated C++ and header files:"
          find "$OUTPUT_DIR" -type f \( -name "*.cpp" -o -name "*.h" \) | head -20
          
          CPP_COUNT=$(find "$OUTPUT_DIR" -name "*.cpp" 2>/dev/null | wc -l)
          H_COUNT=$(find "$OUTPUT_DIR" -name "*.h" 2>/dev/null | wc -l)
          echo ""
          echo "Statistics:"
          echo "  C++ files (.cpp): $CPP_COUNT"
          echo "  Header files (.h): $H_COUNT"
          echo "  Total: $FILE_COUNT"
          
          if [ $FILE_COUNT -gt 20 ]; then
            echo ""
            echo "Note: Only showing first 20 files. Full list available in artifacts."
          fi
      
      - name: Configure Git
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
      
      - name: Commit and push generated files
        run: |
          OUTPUT_DIR="${{ github.workspace }}/${{ inputs.output_directory }}"
          
          # Check if output directory exists and has files
          if [ ! -d "$OUTPUT_DIR" ]; then
            echo "Output directory does not exist, nothing to commit"
            exit 0
          fi
          
          git add "${{ inputs.output_directory }}"
          
          # Add jump tables file if it exists
          if [ -f "jump_tables.toml" ]; then
            git add jump_tables.toml
          fi
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Add generated C++ files from XenonRecomp workflow"
            git push
            echo "Changes pushed successfully"
          fi
      
      - name: Upload generated files as artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: xenonrecomp-output
          path: |
            ${{ inputs.output_directory }}
            jump_tables.toml
            xenonrecomp_config.toml
          retention-days: 7
